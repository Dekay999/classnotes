\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Makro Bilgisi ve Piyasalarýn Gidiþatýnýn Baðlantýsý

Hedgeye kuruluþunun CEO'su Keith Mccollough (KM) baþlangýç olarak iki deðiþkene
bakarak genel olarak hangi varliklara, ne zaman yatýrým yapýlmasý gerektiðine
karar verebilmekte. Bu iki deðiþken enflasyon ve ekonomik büyümedir. Fakat
önemli bir nokta KM bu deðiþkenlerin ikinci türevine bakýyor, yani deðiþimin
deðiþimine, ya da deðiþim hýzýna (rate of change). Fizikle alakalandýrmak
gerekirse enflasyonun ``ivmesinden'' ya da ``frenlemesinden (ters ivme)''
bahsediyor mesela ki ivme ikinci türevdir (mesafenin zamana göre türevi hýz,
onun türevi ivme). Niye ikinci türev? Çünkü KM tarihi veriye bakarak bulmuþtur
ki enflasyon ve büyümenin deðiþim hýzý senetlerin, tahvillerin getirisi ile çok
yakýndan baðlantýlýdýr.

Deðiþimin deðiþimini KM þu þekilde hesaplýyor: ilki yýl-üzeri-yýl
(year-over-year, YoY) üzerinden yani, mesela, bir çeyrek için büyüme yüzdesi
hesaplanacaksa bu ayný senedeki bir önceki çeyreðe deðil, 1 sene önceki ayný
çeyreðe bakýlarak yapýlýyor. Böylece elmalarý elmalar ile karþýlaþtýrmýþ oluruz,
mevsimsel farklýlýklar hakkýnda endiselenmek gerekmez. Eðer 2010 senesindeki
4. çeyrek, 3. çeyrekten büyük ise, belki bu büyüklük kýþ sezonunda bazý
eylemlerin hep daha fazla olmasindan ileri geliyordur, yani büyüme ``gerçek''
deðil sezonsaldýr. Ama 2010 4. çeyreði 2009 4. çeyreði ile karþýlaþtýrýrsak bu
mevsimsel farklýlýklarý hesaba almamýþ oluruz. Bu birinci turev. Bu zaman serisi
hesaplandýktan sonra ikinci ikinci fark (turev) hesabý bir önceki öðeye bakarak
klasik þekilde yapýlabilir.

Enflasyon ayný þekilde, YoY, sonra klasik fark.

Genel olarak düþünmek gerekirse KM makro deðiþkenlerini, ekonomiyi çevrimsel /
dönemsel (cyclic) olarak görüyor, aynen bir yýlýn mevsimleri olduðu gibi. Ýnen
bir süre sonra aþaðý inmek zorundadýr, düþen bir süre sonra yukarý çýkmak
zorundadýr. Bu bir çember görüntüsü kafamýzda oluþturabilir, ya da zaman
indisini de hesaba katarsak saga dogru acilmis bir cember, yani bir sinüs
eðrisinden bahsediyoruz. Her deðiþken KM'e göre bir sinüs eðrisinde hareket
etmektedir; enflasyon ve buyume sinüs eðrilerinin de tabii kendine has
parametreleri olabilir, bazýlarý daha geniþtir belki bazýlarý daha dardýr,
genliði kimisinin daha yüksektir. Farkli ulkelerin buyumeleri de farkli
egrilerde olacaktir. Ama KM tüm deðiþkenleri sinüste farzeder. O zaman metodun
yaptýðý bir deðiþkenin ikinci türevine bakarak sinüs eðrisinin neresinde
olduðunu anlamaya uðraþmaktýr. Bu anlayisin getirdigi ilk rapor altta. 

ABD verisi üzerinde uygulayalým,

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd

df1 = pd.read_csv('quandl-gdp.csv',index_col=0,parse_dates=True)
df2 = pd.read_csv('quandl-inf.csv',index_col=0,parse_dates=True)

df1['gdpyoy'] = (df1.Value - df1.Value.shift(4)) / df1.Value.shift(4) * 100.0
def f(x):
    if x.name.month == 4: return "%d%s" % (x.name.year,"Q1")
    elif x.name.month == 7: return "%d%s" % (x.name.year, "Q2")
    elif x.name.month == 10: return "%d%s" % (x.name.year, "Q3")
    elif x.name.month == 1: return "%d%s" % (x.name.year-1, "Q4")

df1['Q'] = df1.apply(f, axis=1)
print (df1[['gdpyoy','Q']].tail(3))

df2['cpi'] = df2.resample('Q')[['Value']].mean()
df2c = df2.dropna()

def f(x):
    if x.name.month == 3: return "%d%s" % (x.name.year,"Q1")
    elif x.name.month == 6: return "%d%s" % (x.name.year, "Q2")
    elif x.name.month == 9: return "%d%s" % (x.name.year, "Q3")
    elif x.name.month == 12: return "%d%s" % (x.name.year, "Q4")

df2c['Q'] = df2c.apply(f, axis=1)
print (df2c[['cpi','Q']].tail(3))
print (df2c.tail(3))
\end{minted}

\begin{verbatim}
              gdpyoy       Q
Date                        
2018-01-01  2.580414  2017Q4
2018-04-01  2.869807  2018Q1
2018-07-01  3.039632  2018Q2
                 cpi       Q
Date                        
2018-03-31  2.214333  2018Q1
2018-06-30  2.712000  2018Q2
2018-09-30  2.642000  2018Q3
            Value   ...         Q
Date                ...          
2018-03-31  2.360   ...    2018Q1
2018-06-30  2.872   ...    2018Q2
2018-09-30  2.277   ...    2018Q3

[3 rows x 3 columns]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
df = df1[['gdpyoy','Q']].merge(df2c[['cpi','Q']], on='Q')
df['gdpyoy'] = df.gdpyoy.shift(1)
df['gdpdiff'] = df.gdpyoy.diff()
df['cpidiff'] = df.cpi.diff()
df = df.dropna()
\end{minted}

Deðiþim hýzýný üstteki þekilde elde edince þimdi çok önemli bir raporu ortaya
çýkarmak mümkün. Ýki deðiþken +, -, yani ivmeleneme, frenleme üzerinden 4 farklý
þekilde kombine edilebilir; hem büyümede hem enflasyonda ivme vardýr, ya da
büyümede ivme enflasyonda fren vardýr, vs. bu dört kombinasyonu Quad (Bölge) 1,
Quad 2, Quad 3, .. diye ayrýlir. KM her quad'ýn kendine has özellikleri, yatýrým
usulleri oldugunu soyler (cunku gecmise donuk analizi ona bu fikri vermistir).

\begin{minted}[fontsize=\footnotesize]{python}
import random
plt.xlim(-1.0,1.0)
plt.ylim(-1.0,1.0)
plt.grid()
res = df[['Q','cpidiff','gdpdiff']].tail(14)
for (q,x,y) in np.array(res):
    plt.plot(x,y,'rd')
    xa = random.choice(np.linspace(0,0.05,3))
    plt.text(x+xa,y+xa,q)
plt.savefig('tser_macromkt_03.png')    
\end{minted}

\includegraphics[width=20em]{tser_macromkt_03.png}

Gecmis donuk Quad'larin nerede oldugunu goruyoruz. Quad 1 iyi, Quad 2 çok
iyi. Her iki durumda da büyüme yukarý çýkýyor. Quad 2'de büyüme ve enflasyon
ayný anda yukarý çýkýyor. Bu bölgede herþey kazanýyor, tek istisnalar altýn,
tahviller ve dolar. Kýyasla Quad 4'te büyüme ve enflasyon ayný anda aþaðý
iniyor, burada dolar, aþaðý beta defansif hisseler, günlük ihtiyaçlara hitab
eden þirketler (enerji, alýþveriþ, vs), tahviller. Satýlacaklar momentum,
büyüme, ve Google, Microsoft gibi teknoloji þirketleri.

Not: Beta bir senetin tüm borsaya nazaran oynaklýðýyla alakalý, borsadaki tüm
senetler üzerinden hesaplanan oynaklýk sayýsý 1 kabul edilir, bunun altýnda (kat
baðlamýnda) olan her diðer senet oynaklýðý bu beta biriminden raporlanýr. Mesela
bir senetin oynaklýðý borsa oynaklýðýnýn iki katýysa ona ``2 beta'' senedi
denir, yarýsýysa ``0.5 beta''.

Quad 3 stagflasyon. Bu noktaya çoðunlukla Quad 4'te olduðunu farkeden merkez
bankalarý yüzünden gelinir. Merkez bankaçý panikleyerek kuru devalaue eder,
deðerini indirir, ve ``varlýk fiyatý enflasyonu'' yaratýrlar, senetlerde, emlak
piyasasýnda mesela. Çinliler bunu 2018'de yaptýlar, Quad 4'teydiler, yuan'ý
yüzde 4 devalüe ettiler, ve varlýklarda enflasyon pompalayarak ``büyüme hayali''
yarattýlar, ama sonucunda ekonomik stagflasyona mahkum oldular.

Enflasyon ve büyüme bu kadar önemli kararlarý etkilediði için onlarý tahmin
edebilen makro geleceði tahmin eder, ve Hedgeye þirketi bu ise müthiþ
odaklýdýr. Aslýnda kabaca düþününce bu tahminin imkansýz olmayacaðý anlaþýlýr,
eðer sinüs eðrisinin neresinde olacaðýmýzý tahmin etmeye uðraþýyorsak, bunu
nerede olduðumuza, nereden geldiðimize bakarak yapabilmemiz gerekir. HE
hakikaten YoY verisinden geriye bakarak ortalamaya donus zamanini tahmin
edebiliyor. Tam degisim hizi tahmini icin 30 tane faktoru kullanarak bir diger
regresyon yapiyorlar [10]. 

Oynaklik 

\begin{minted}[fontsize=\footnotesize]{python}
from scipy.stats import norm
import datetime, numpy as np

def find_vol(target_value, call_put, S, K, T, r):
    MAX_ITERATIONS = 100
    PRECISION = 1.0e-5

    sigma = 0.5
    for i in range(0, MAX_ITERATIONS):
        price = bs_price(call_put, S, K, T, r, sigma)
        vega = bs_vega(call_put, S, K, T, r, sigma)
        price = price
        diff = target_value - price  # our root

        print (i, sigma, diff)

        if (abs(diff) < PRECISION): return sigma
        sigma = sigma + diff/vega # f(x) / f'(x)

    return sigma


n = norm.pdf
N = norm.cdf

def bs_price(cp_flag,S,K,T,r,v,q=0.0):
    d1 = (np.log(S/K)+(r+v*v/2.)*T)/(v*np.sqrt(T))
    d2 = d1-v*np.sqrt(T)
    if cp_flag == 'c':
        price = S*np.exp(-q*T)*N(d1)-K*np.exp(-r*T)*N(d2)
    else:
        price = K*np.exp(-r*T)*N(-d2)-S*np.exp(-q*T)*N(-d1)
    return price

def bs_vega(cp_flag,S,K,T,r,v,q=0.0):
    d1 = (np.log(S/K)+(r+v*v/2.)*T)/(v*np.sqrt(T))
    return S * np.sqrt(T)*n(d1)

def test1():
    
    V_market = 17.5
    K = 585
    T = (datetime.date(2014,10,18) - datetime.date(2014,9,8)).days / 365.
    S = 586.08
    r = 0.0002
    cp = 'c' # call option
    
    implied_vol = find_vol(V_market, cp, S, K, T, r)
    
    print ('Implied vol: %.2f%%' % (implied_vol * 100))
    
    print ('Market price = %.2f' % V_market)
    print ('Model price = %.2f' % bs_price(cp, S, K, T, r, implied_vol))

test1()
\end{minted}

\begin{verbatim}
0 0.5 -21.669539271534063
1 0.21879739316064523 0.03217154881230044
2 0.21921383628613422 1.9891615465894574e-08
Implied vol: 21.92%
Market price = 17.50
Model price = 17.50
\end{verbatim}


\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
import numpy as np
from datetime import datetime
from datetime import date
import pandas_datareader.data as web

pd.set_option('display.notebook_repr_html', False)
pd.set_option('display.max_columns', 7)
pd.set_option('display.max_rows', 10) 
pd.set_option('display.width', 82) 
pd.set_option('precision', 3)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
aapl_options = pd.read_csv('aapl_options.csv',  parse_dates=['Expiry'])
aapl_options['IV'].tail(4)

aos = aapl_options.sort_values(['Expiry', 'Strike'])[['Expiry', 'Strike', 'Type', 'IV', 'Bid', 'Ask', 'Underlying_Price']] 
aos['IV'] = aos['IV'].apply(lambda x: float(x.strip('%')))
aos[:5]

aos['Expiry'].unique()

aos.loc[158]

calls1 = aos[(aos.Expiry=='2015-02-27') & (aos.Type=='call')]
calls1[:5]
\end{minted}

\begin{verbatim}
Out[1]: 
        Expiry  Strike  Type      IV    Bid    Ask  Underlying_Price
158 2015-02-27    75.0  call  271.88  53.60  53.85            128.79
190 2015-02-27    80.0  call  225.78  48.65  48.80            128.79
226 2015-02-27    85.0  call  199.22  43.65  43.80            128.79
265 2015-02-27    90.0  call  175.00  38.65  38.80            128.79
303 2015-02-27    93.0  call  160.16  35.65  35.80            128.79
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
df = pd.read_csv('GOOG.csv')
print (len(df))
print (np.std(df['Close'].head(254).pct_change()) * np.sqrt(252))
print (np.std(df['Close'].tail(254).pct_change()) * np.sqrt(252))
#print (df['Close'])
\end{minted}

\begin{verbatim}
274
0.23989196101316274
0.24679150720580836
\end{verbatim}


1-4 main, 5-8 vol

Kaynaklar

[1] Hedgeye, Ana Ders, \url{www.youtube.com/watch?v=hS-JOXZrcdU}

[2] Hedgeye, Ana Ders, \url{www.youtube.com/watch?v=2NvNGAIvcb0}

[3] Hedgeye, Ana Ders, \url{youtu.be/V-uoyDj0tKs}

[4] Hedgeye, Ana Ders, \url{youtu.be/27SQ5mYf38k}

[5] Hedgeye, Oynaklik, \url{youtube.com/watch?v=FwpckOfUyRk}

[6] Hedgeye, Oynaklik, \url{youtube.com/watch?v=-WJtepxbQbE}

[7] Hedgeye, Oynaklik, \url{youtube.com/watch?v=USrojq9tgzs}

[8] Hedgeye, Oynaklik, \url{http://www.codeandfinance.com/finding-implied-vol.html}

[9] Heydt, {\em Mastering Pandas for Finance}

[10] Hedgeye, \url{http://app.hedgeye.com/mu/he_2q18_macrothemes_update_5-4-2018?encoded_data=ftvm,3MW2y7jAWWk/RR9BK6C07dDZp9A=,}

\end{document}

