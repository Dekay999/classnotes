\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Geri-Yansýtmayla 3D Iþýn Hesabý (Back-projecting a 3D Ray), ve Düzlem Mesafesi

Üç boyutlu bir noktanýn iki boyuta yansýmasýnda derinlik bilgisinin
kaybolduðunu gördük, birden fazla üç boyutlu nokta ayný piksele tekabül
edebiliyor. Bu durumda sadece piksel kullanarak obje mesafe ölçümünü tek
bir görüntü üzerinden nasýl yapabiliriz? 

Eðer derinlik bilgisini kaybettiysek o zaman resimde bilinen diðer bazý
faktörleri yanyana koyarak bir uzaklýk hesaplayabiliriz belki. Mesela
alttaki resimdeki kýrmýzý piksellerin mesafesini bulmak istiyorum.

\begin{minted}[fontsize=\footnotesize]{python}
from PIL import Image
import util

im = np.array(Image.open('mitte.png'))
plt.xlim(0,320)
plt.ylim(240,0)
plt.imshow(im)
h = np.array(im).shape[0]

np.random.seed(1)
quad = np.array([[140,0],[164,90.],[212,90],[234,0]])
util.plot_quad(quad, h, 'y')
N = 1000 
random_points = np.random.uniform(0, 320, (N, 2)).astype(np.int)
random_points = random_points[random_points[:,1] < 240]
mask = np.array([util.inside_quad(quad, p)[0] for p in random_points])
plt.plot(random_points[mask][:,0], h-random_points[mask][:,1], 'r.')
plt.savefig('vision_80ray_02.png')
\end{minted}

\includegraphics[width=20em]{vision_80ray_02.png}

Problem öyle ki bu piksellerin yolu temsil eden pikseller olduðunu
biliyorum. Bu bilgiyi nasýl elde ettim? Renksel bazlý, ya da iki boyutta
imajý parçalara bölmeyi çok iyi yapan bir algoritmam var belki, vs. ve bu
sayede o piksellerin caddeye ait oldugunu biliyorum. O zaman, bu bilgi elde
varsa, bu bana bir þey kazandýrdý: üç boyutta bu piksellerin {\em hangi
  düzlemden} geldiðini biliyorum artýk. Bu düzlem $xy$ düzlemidir, orada
$z=0$.

Bir numara daha: bir piksele bakarak onun kesin üç boyutlu yerini
hesaplayamayabilirim. Ama bir piksele tekabül eden, onu oluþturan kamera
merkezinden dünyaya doðru fýrlayan bir ýþýnýn (ray) kesin formülünü
hesaplayabilirim.

\includegraphics[width=20em]{vision_80ray_01.png}

Mesela örnek kýrmýzý piksellerden biri $p_1$ noktasý olabilir, kamera
merkezi $C$'den bir ýþýn fýrlatýyoruz, bu ýþýn $p_1$'i oluþturuyor ve dýþ
dünyadaki bir $X$ noktasýna doðru gidiyor.  Þimdi bu iki fikri biraraya
koyarsak, elde bir düzlem, bir ýþýn var; üç boyutlu yer nasýl bulunur?
Ikisinin kesiþtiði yer ile! Bu nokta yol noktasýnýn üç boyutlu
kordinatýdýr.

Kamera Merkezi

Iþýnlar kamera merkezinden geleceði için önce eðer bilmeseydik, ve elde
sadece $P$ matrisi olsa, kamera merkezini nasil hesaplarýz onu
görelim. Biraz önceki resmi iþlerken kameranýn yerden 1 metre yükseltilmiþ
olduðunu farzedeceðiz (bunu biliyoruz), fakat bazen bu bilgi verilmemiþ
olabilir. Bu durumda dýþsal matristen baþlayabiliriz.

Dýþsal (exintrinsic) matrisler dýþ dünya kordinatlarýnýn kamera
kordindatlarýna nasýl transform edildiðini tarif ederler. Bunun yerine
kamera duruþunu modelleyip oradan geriye gidersek ayný noktaya gelmiþ
oluruz [1].

$$ 
\left[
\begin{array}{c|c} R & \boldsymbol{t} \\ \hline  \boldsymbol{0} & 1 \\ \end{array}
\right]
 = 
\left[ \begin{array}{c|c} R_c & C \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]^{-1} 
$$

$$ 
= \left[ 
\left[ \begin{array}{c|c} I & C \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]
\left[ \begin{array}{c|c} R_c & 0 \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]
\right]^{-1}
$$

$$ 
= 
\left[
\begin{array}{c|c} R_c & 0 \\ \hline \boldsymbol{0} & 1 \\ \end{array} 
\right]^{-1} 
\left[ \begin{array}{c|c} I & C \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]^{-1}
$$

$$ 
= 
\left[\begin{array}{c|c} R_c^T & 0 \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]
\left[ \begin{array}{c|c} I & -C \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]
$$

$$ 
= 
\left[\begin{array}{c|c} R_c^T & -R_c^TC \\ \hline \boldsymbol{0} & 1 \\ \end{array}
\right]
$$

Birbirine tekabül eden hücrelere bakýnca 

$$ t = -R_c^TC$$

O zaman 

$$ C = -R_c^T t$$

Burada $R_c$ $P$ yansýtma matrisinin ilk üç kolonundan oluþan
matristýr. Ayrýca kamera merkezinin içsel matris $K$'ye baðlý olmadýðýna
dikkat. 

Sözde Ters ile $X$

Þimdi $X$ bulmak lazým. Bir fikir akla geliyor, $PX = x$ olduðuna göre,
$P$'nin tersini soldan uygulasak olmaz mý? Burada bir problem var, $P$
matrisi $3 \times 4$ matrisi, kare matris olmadýðý için tersi
alýnamýyor. Bu hesap için 2. derste iþlenen sözde ters (pseudoinverse)
iþlemini kullanacaðýz. Hatýrlatarsak, $P$'nin sözde tersi $P^{\dag}$

$$ P^{\dag} = P^T(PP^T)^{-1}$$

iþlemidir, ki $PP^{\dag} = I$. Üstteki $PP^T$ çarpýmýna aldanmayalým, bu
çarpým çok büyük sayýlara sebep olacaðý için numerik stabiliteyi bozar diye
haklý olarak endiþe edilebiliyor, sayýsal kütüphaneler bu iþlemi SVD
üzerinden çözüyor (çok hýzlý), bkz. 2. ders. 

O zaman $P^{\dag}x$ ile bahsettiðimiz ýþýndaki bir noktayý buluruz. Dikkat,
sadece birini buluruz, diðer noktalar da mümkündür. Ama o noktalar bizi
ilgilendirmiyor (þimdilik) elimizde iki nokta olacak, biri kamera merkezi
diðeri bu hesaplanacak olan, bu ikisi yeterli.

Ama ondan önce üstteki hesabýn gerçekten bir $X$ verip vermediðini kontrol
edelim, hesaplanan noktayý tekrar geri kameraya yansýtýrsak ne olur?

$$ P (P^{\dag}x) = Ix = x$$

Hesap doðruymuþ demek ki. 

Altta iki nokta (yani çizgi) ve düzlem (bir nokta, bir normal) arasýnda
kesiþmeyi hesaplayan çaðrý kodlandý. Üstteki gördüðümüz kýrmýzý noktalý
pikselleri alýp, onlarýn ýþýný bulacaðýz, sonra o ýþýnýn $xy$ düzlemi ile
kesiþmesini bulacaðýz. Kamera matrisi $K$'yi biliyoruz, çünkü kamerayý biz
kalibre ettik, detaylar için [2].

\begin{minted}[fontsize=\footnotesize]{python}
def intersect(n,V0,P0,P1):
    """
    n: duzleme normal vektor
    V0: duzlemdeki herhangi bir nokta
    P0: P0P1 cizgisinin bir ucu
    P1: P0P1 cizgisinin diger ucu
    """
    w = P0 - V0;
    u = P1-P0;
    N = -np.dot(n,w);
    D = np.dot(n,u)
    sI = N / D
    I = P0+ sI*u
    return I

import scipy.linalg as lin

K = [[ 282.363047,      0.,          166.21515189],
     [   0.,          280.10715905,  108.05494375],
     [   0.,            0.,            1.        ]]
K = np.array(K)
R = np.eye(3)
t = np.array([[0],[1.],[0]])
P = K.dot(np.hstack((R,t)))
C = np.array([0., 0., 1.])

xx = np.ones((len(random_points[mask]), 3))
xx[:,0] = random_points[mask][:,0]
xx[:,1] = h-random_points[mask][:,1]

xyp = np.array([0,0,0])
xyn = np.array([0,0,1.])

for x in xx:
    X = np.dot(lin.pinv(P),np.array(x))
    X = X / X[3]
    XX  = np.copy(X)
    # Y-Z degistir, Y'nin isaretini degistir
    XX[1] = X[2]; XX[2] = X[1]; XX[2] = -XX[2]
    Xi = intersect(xyn, xyp, XX[:3], C)
    plt.plot(Xi[0], Xi[1],'b.')

plt.xlim(-3,3)
plt.ylim(0,20)
plt.savefig('vision_80ray_03.png')
\end{minted}

\includegraphics[width=20em]{vision_80ray_03.png}

Üstteki görüntü kýrmýzý piksellerin 3 boyutta caddedeki kuþbakýþý
görüntüsü. Noktalar mantýklý, bir saða kayýþ var, bu doðru çünkü her ne
kadar iki boyutlu görüntüde noktalar yukarý gidiyor gibi dursa da, aslýnda
kesiþme noktasýna giden çizginin saðýna doðru akmýþlar. Bir diðer durum en
altta birkaç metrelik bir kýsmýn boþ olmasý. Bu da mantýklý çünkü kamera
direk altýný göremiyor, en yakýn görebildiði noktalar biraz daha önde
olanlar.

Peki kameranýn duruþunu biliyorum, yere paralel, 1 metre yukarýda. Bu
bilgiyi kullanarak çizgiler ve açýlarý daha basit þekilde
hesaplayabilirdim, niye bunu yapmadým? Özellikle $P$ matrisini
kullanmamýzýn sebebi, eðer yer deðiþtirmeye ek olarak dönüþ te varsa bu
bilginin $P$ içinde olacaðýdýr. Bu durumda üstteki sözde ters ile yine
direk bir ýþýn elde edebilirdik. Öteki türlü çetrefil bir sürü ek hesaplara
girmek gerekecekti. 

Kaynaklar

[1] Kyle Simek, Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix,
\url{http://ksimek.github.io/2012/08/22/extrinsic/}

[2] Bayramli, {\em Algýlayýcý Ölçümleri, Video, Android}, \url{http://sayilarvekuramlar.blogspot.de/2017/02/algilayici-olcumleri-video-android.html}

\end{document}
