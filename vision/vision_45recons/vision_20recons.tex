\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Ýki Ýmaj Kullanarak 3 Boyutta Tekrar Oluþturmak (3D Reconstruction from Two Images)

Temel Matris 

Daha önce vazgeçilmez matris (essential matris) konusunu görmüþtük. Þimdi
bu konuya ve yani bölümde iþlenen eskutupsal kýsýtlamayý (epipolar
contraint) bir daha anlatalým, bu sefer temel matris (fundamental matrix)
denen bir kavramý merkez alarak. Aslýnda vazgeçilmez ve temel matrisler
birbirine çok yakýnlar, temel matris vazgeçilmezin içinden kalibre edilmiþ
matris faraziyesinin çýkartýlmýþ hali. [1, sf. 257] diyor ki vazgeçilmez
matriste her þey vazgeçilmez deðilmiþ demek ki (!).

Kalibrasyon, yani $K$ faraziyesi þöyle çýkartýlýr: diyelim ki bir kamera
matrisi $P = K[R | t]$ olarak tanýmlý ve $x = PX$ görüntüdeki bir piksel
noktasý. Bilinen bir $K$ varsa onun tersini $x$'e uygulayarak
$\hat{x} = K ^{-1}x$ noktasýný elde edebiliriz, o zaman
$\hat{x} = [R | t]X$ olur. Burada $\hat{x}$'i bir tür ``normalize edilmiþ''
kordinate sistemindeki bir görüntü pikseli olarak düþünebiliriz, bu sistem
sanki kalibrasyonu birim matris olan bir kamera sistemidir. Ayný þekilde
$K ^{-1} P = [R|t]$ normalize kamera matrisi olarak adlandýrýlýr.

Þimdi eþkutupsal kýsýtlamaya tekrar bakalým. Altta soldaki resimde üç
boyutlu gerçek dünyada bir $X$ noktasý var, bu noktadan merkezi $C_1$'de
olan kameraya bir çizgi çekiyoruz. Bu çizgi üzerindeki her nokta aslýnda
ayný piksel noktasýna tekabül eder. Þimdi bu çizgi üzerindeki tüm o
noktalarýn ikinci bir kameradaki yansýmalarýný düþünelim. Bu tüm deðiþik
yansýmalar ikinci kameranýn görüntüsünde bir çizgi oluþtururlar, bu çizgiye
eþkutupsal çizgi diyoruz (alt saðdaki resim). 

\includegraphics[width=17em]{vision_20recons_04.png}
\includegraphics[width=17em]{vision_20recons_05.png}

Þimdi þu resme bakalým,

\includegraphics[width=22em]{vision_20recons_06.png}

Nokta $x$'i alýp $x'$ noktasýna transfer eden bir fonksiyon var, buna
$H_{\pi}$ diyelim. Tranfer 2D-2D, yani iki boyuttan iki boyuta bir geçiþ,
bir homografi, ve $\pi$ düzlemi üzerinde bu geçiþ oluyor. Ýkinci kameradaki
eþkutupsal çizgi $l' = [e']_x x'$ ile elde edilir, çünkü hatýrlarsak iki
noktadan çizgi elde etmek için çapraz çarpým lazým, ya da vektörlerden
birinin eksi bakýþýmlý hali ile normal çarpým. O zaman, ve $x' = H_\pi x$
olduðu için,

$$ l' = [e']_x x' = l' = [e']_x H x = F x $$

de denebilir. Burada denklemin $[e']_xH$ kýsmýna temel matris $F$ denir. 

Eþkutupsal kýsýtlama

$$ x'^T F x = 0$$

ifadesidir. Bu doðru çünkü eðer $x$ ve $x'$ birbirlerine karþýlýk noktalar
iseler, o zaman $x'$ eþkutupsal çizgi $l' = Fx$ üzerinde olmalý, yani
$0 = x'^T l' = x'^T F x$.

Nokta Karþýlýklarý ve 8-Nokta Algoritmasý

Ýki resimden üç boyutta tekrar oluþturma için önce $F$ matrisini hesaplamak
gerekiyor. Oradan vazgeçilmez matris $E$'ye geçeceðiz, ve $E$ içinden $R,T$
matrislerini çýkartacaðýz. $F$'den $E$'ye geçiþ basit, $E = K^TFK$. Ýspat:
Eðer eþkutupsal kýsýtlama türetiminde normalize edilmiþ noktalarý
kullansaydýk $\hat{x}'E \hat{x} = 0$ elde ederdik, ve $\hat{x},\hat{x}'$
yerine $x,x'$ için $\hat{x} = K ^{-1}x, \hat{x'} = K ^{-1}x'$ sokarsak, o
zaman $x'^TK^{-T}E K ^{-1}x = 0$ elde ederiz, bu demektir ki
$E = K ^T F K$.

$F$ hesabýna gelelim. Elimizde iki imaj var, Alkatraz adasýnýn iki deðiþik
yerden fotoðrafý [2,3]. Bu iki imaj üzerinde önce birbirine tekabül eden
noktalarý bulacaðýz. Bu iþ için OpenCV'nin ORB adý verilen nokta özelliði
(feature) cikartan iþlevini kullanabiliriz, onun yerine SIFT, SURF te
olabilirdi.

\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import axes3d
import scipy.linalg as lin
import cv2

dir = "/home/burak/Documents/Dropbox/Public/data/pcv_data"
img1 = cv2.imread(dir + "/alcatraz1.jpg")
img2 = cv2.imread(dir + "/alcatraz2.jpg")

detector = cv2.ORB_create( nfeatures = 10000 )

def detect_features(frame):
    keypoints, descrs = detector.detectAndCompute(frame, None)
    if descrs is None: descrs = []
    return keypoints, descrs

FLANN_INDEX_LSH    = 6
flann_params= dict(algorithm = FLANN_INDEX_LSH,
                   table_number = 6, # 12
                   key_size = 12,     # 20
                   multi_probe_level = 1) #2


kp1, des1 = detect_features(img1)
kp2, des2 = detect_features(img2)

matcher = cv2.FlannBasedMatcher(flann_params, {})
matches = matcher.knnMatch(des1, des2, k = 2)

matches = [m[0] for m in matches \
           if len(m) == 2 and m[0].distance < m[1].distance * 0.75]

print 'matches', len(matches)

pts1 = []; pts2 = []

for i in range(len(matches)):
    pt_a = kp1[matches[i].queryIdx].pt
    pt_b = kp2[matches[i].trainIdx].pt
    pt_a = np.array(pt_a).astype(int)
    pt_b = np.array(pt_b).astype(int)
    if np.sqrt(np.dot(pt_b-pt_a,pt_b-pt_a)) < 200:
        pts1.append(pt_a)
        pts2.append(pt_b)
        cv2.line(img1, tuple(pt_a), tuple(pt_b), (255, 0, 0), 5)
        cv2.circle(img1,tuple(pt_b), 5, (0,0,255), -1)

h,w,d = img1.shape
tmp = cv2.resize(img1, (int(w/4),int(h/4)))
cv2.imwrite('vision_20recons_01.jpg',tmp)

for pt in pts2: cv2.circle(img2,tuple(pt),5,(0,0,255),-1)
tmp = cv2.resize(img2, (int(w/4),int(h/4)))
cv2.imwrite('vision_20recons_02.jpg',tmp)

pts1 = np.array(pts1)
pts2 = np.array(pts2)

h,w,dum = img1.shape
pts1[:,1] = h-pts1[:,1]
pts2[:,1] = h-pts2[:,1]
\end{minted}

\begin{verbatim}
matches 1290
\end{verbatim}

\includegraphics[width=30em]{vision_20recons_01.jpg}

\includegraphics[width=30em]{vision_20recons_02.jpg}

Birinci resimde saptanan ORB noktalarýnýn ayný resimdeki noktalara nasýl
eþleþtiðini gösterdik, ikinci resimde ayný bu noktalar görülüyor. Eslenen
noktalarin kaymasi kameraninin hareketi hakkinda bir ipucu verdigi ciplak
gozle bile goruluyor. Temel matrisi hesaplayarak daha net bir sonuc
alabiliriz. 

8-Nokta Algoritmasi



\begin{minted}[fontsize=\footnotesize]{python}
def compute_fundamental(x1, x2):
  '''Computes the fundamental matrix from corresponding points x1, x2 using
  the 8 point algorithm.'''
  n = x1.shape[1]
  if x2.shape[1] != n:
    raise ValueError('Number of points do not match.')

  # Normalization is done in compute_fundamental_normalized().
  A = np.zeros((n, 9))
  for i in range(n):
    A[i] = [x1[0, i] * x2[0, i],  x1[0, i] * x2[1, i],  x1[0, i] * x2[2, i],
            x1[1, i] * x2[0, i],  x1[1, i] * x2[1, i],  x1[1, i] * x2[2, i],
            x1[2, i] * x2[0, i],  x1[2, i] * x2[1, i],  x1[2, i] * x2[2, i],
           ]

  # Solve A*f = 0 using least squares.
  U, S, V = np.linalg.svd(A)
  F = V[-1].reshape(3, 3)

  # Constrain F to rank 2 by zeroing out last singular value.
  U, S, V = np.linalg.svd(F)
  S[2] = 0
  F = np.dot(U, np.dot(np.diag(S), V))
  return F / F[2, 2]

def make_homog(points):
  return np.vstack((points, np.ones((1, points.shape[1]))))

print compute_fundamental(make_homog(pts1.T),make_homog(pts2.T))
\end{minted}

\begin{verbatim}
[[  8.29708245e-08   5.53218101e-07  -1.17004785e-03]
 [  1.08768393e-07   8.91858158e-07  -3.47847848e-03]
 [  3.12214921e-04   1.61877427e-03   1.00000000e+00]]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
# kamera matrisi biliniyor
K = np.array([[2394,0,932],[0,2398,628],[0,0,1]])

F, mask = cv2.findFundamentalMat(pts1,pts2)
print F
E = K.T.dot(F).dot(K)

R1,R2,t = cv2.decomposeEssentialMat(E)
\end{minted}

\begin{verbatim}
[[ -5.44722052e-08   9.22019433e-07   1.17985628e-03]
 [ -1.26508496e-06   7.74814744e-07   1.15134028e-02]
 [ -1.29297913e-03  -1.31947419e-02   1.00000000e+00]]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
def triangulate_point(u1, u2, P1, P2):
  A = [[u1[0]*P1[2,0]-P1[0,0],u1[0]*P1[2,1]-P1[0,1],u1[0]*P1[2,2]-P1[0,2]],
       [u1[1]*P1[2,0]-P1[1,0],u1[1]*P1[2,1]-P1[1,1],u1[1]*P1[2,2]-P1[1,2]],
       [u2[0]*P2[2,0]-P2[0,0],u2[0]*P2[2,1]-P2[0,1],u2[0]*P2[2,2]-P2[0,2]],
       [u2[1]*P2[2,0]-P2[1,0],u2[1]*P2[2,1]-P2[1,1],u2[1]*P2[2,2]-P2[1,2]]]
  B = [[-(u1[0]*P1[2,3]-P1[0,3])],
       [-(u1[1]*P1[2,3]-P1[1,3])],
       [-(u2[0]*P2[2,3]-P2[0,3])],
       [-(u2[1]*P2[2,3]-P2[1,3])]]
  A = np.array(A)
  B = np.array(B)
  X = lin.lstsq(A,B)[0].T[0]
  res = np.array([X[0],X[1],X[2],1])
  return res

def triangulate(x1, x2, P1, P2):
  X = [triangulate_point(x1[i, :], x2[i, :], P1, P2) for i in range(len(x1))]
  return np.array(X).T

P1 = np.eye(4)
P2 = np.array([[ 0.878, -0.01 ,  0.479, -1.995],
              [ 0.01 ,  1.   ,  0.002, -0.226],
              [-0.479,  0.002,  0.878,  0.615],
              [ 0.   ,  0.   ,  0.   ,  1.   ]])
# Homogeneous arrays
a3xN = np.array([[ 0.091,  0.167,  0.231,  0.083,  0.154],
                 [ 0.364,  0.333,  0.308,  0.333,  0.308],
                 [ 1.   ,  1.   ,  1.   ,  1.   ,  1.   ]])
b3xN = np.array([[ 0.42 ,  0.537,  0.645,  0.431,  0.538],
                 [ 0.389,  0.375,  0.362,  0.357,  0.345],
                 [ 1.   ,  1.   ,  1.   ,  1.   ,  1.   ]])
X = triangulate_point( a3xN.T[0], b3xN.T[0], P1, P2 )
X /= X[3]
x1 = np.dot(P1[:3],X)
x2 = np.dot(P2[:3],X)
x1 /= x1[2]
x2 /= x2[2]
 
print 'X', X
print 'x', x1
print 'x2', x2
\end{minted}

\begin{verbatim}
X [  1.00277411   4.01217675  11.01977032   1.        ]
x [ 0.09099773  0.36408896  1.        ]
x2 [ 0.4200205   0.38890029  1.        ]
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
for i,P in enumerate(((R1,t),(R1,-t),(R2,t),(R2,-t))):

    P1 = K.dot(np.hstack(P))       # Projection matrix of second cam is ready
    P00 = np.float64([ [1,0,0,0],
                       [0,1,0,0],
                       [0,0,1,0]   ]) # Projection matrix of first cam at origin
    P0 = K.dot(P00) 

    X = triangulate(pts1, pts2, P0, P1)

    fig = plt.figure()
    ax = fig.gca(projection='3d')    
    ax.plot(X[0], X[2], X[1], 'r.')
    ax.view_init(elev=23., azim=-67)
    plt.savefig('vision_20recons_03_%d.png' % i)
\end{minted}

\includegraphics[width=20em]{vision_20recons_03_0.png}
\includegraphics[width=20em]{vision_20recons_03_1.png}
\includegraphics[width=20em]{vision_20recons_03_2.png}
\includegraphics[width=20em]{vision_20recons_03_3.png}



Kaynaklar

[1] Zisserman, {\em Multiple View Geometry in Computer Vision 2nd Edition}

[2] Bayramli, {\em Alkatraz Resmi 1}, \url{https://www.dropbox.com/s/luuymnbh1njmz1v/alcatraz1.jpg?dl=1}

[3] Bayramli, {\em Alkatraz Resmi 2}, \url{https://www.dropbox.com/s/ms3cp4htkxd8pw8/alcatraz2.jpg?dl=1}


\end{document}




















