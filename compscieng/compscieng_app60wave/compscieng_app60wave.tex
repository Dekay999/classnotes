\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Frekans Verisi Bazlý Uygulamalar

Adým Ölçmek, Pedometre

Cep telefonlarýnýn çoðunda artýk ivmeölçer (acceloremeter) algýlayýcýlar
var; bu algýlayýcýlar telefonun $x,y,z$ eksenlerini baz alarak bu
eksenlerde ne kadar ivme etkisi olduðunu ölçüyorlar. 

Bu etkilerden en büyüklerinden biri tabii ki yerçekimi, telefonda hiçbir
hareket olmasa bile telefonu tutuþa göre 9.8 metre / $s^2$'lik bir ivme tek
ya da tüm eksenlere daðýlmýþ olarak ölçülecektir. Yürürken, adým atarken
meydana çýkan yukarý ve aþaðý yönde kuvvet uygulamasý da ivmeölçerlerle
yakalanabilmeli. Bu ölçümleri kullanarak acaba atýlan adým sayýsýný bulamaz
mýyýz? [8]'deki uygulamayý kullanarak alýnan ölçümlere bakalým,

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
dfacc = pd.read_csv('acc.txt',header=None,sep='\s+')
print dfacc.head()
\end{minted}

\begin{verbatim}
               0         1         2         3
0  1493818386218 -0.147100  6.972528  6.707748
1  1493818386422 -0.215746  7.001948  6.854848
2  1493818386610 -0.304006  7.041174  6.697942
3  1493818386812 -0.304006  7.050981  6.884268
4  1493818387008 -0.225553  7.011754  6.943108
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
steps1 = np.sqrt(np.sum(dfacc[[1,2,3]]**2, axis=1))
steps2 = steps1 - 9.8
steps2[:200].plot()
plt.savefig('compscieng_app60wave_01.png')
\end{minted}

\includegraphics[height=6cm]{compscieng_app60wave_01.png}

Üç eksendeki ivme ölçümünün normalize ettik (karelerinin toplamýnýn
kareköku) - daha önce belirtildiðimiz gibi telefonun duruþu deðiþik
þekillerde olabilir, ve yerçekiminde olduðu gibi bu ölçümler üç eksene
daðýlmýþ olacaktýr. Bu üç ölçümü birleþtirerek esas bizi ilgilendiren
hesaba daha yaklaþmýþ olmayý umduk. Sonuçlar fena deðil, baþtaki sýfýra
yakýn bölgede hiç hareket etmiyorduk mesela, ve ivme hesabý burada ufak
bir deðer gösteriyor.

Yapýlan bir ek iþlemden daha bahsedelim, 9.8'lik yerçekimi ivmesini
karekökten çýkarttýk çünkü yerçekimini ölçmekle de ilgilenmiyoruz (hep ayný
zaten), bu deðeri çýkartarak yine bizi ilgilendiren veriyi daha net þekilde
görebileceðimizi umduk. Altta bu çýkartma öncesi ve sonrasýnda yapýlan
Fourier analizine göre yerçekimi çýkartýlmýþ verinin bizim ilgilendiðimiz
frekanslarý daha net gösterdiði belli oluyor.

\begin{minted}[fontsize=\footnotesize]{python}
import sys; sys.path.append('../compscieng_1_32')
import filt
f=plt.figure()
filt.plotSpectrum(steps1, 6)
plt.savefig('compscieng_app60wave_02.png')
f=plt.figure()
filt.plotSpectrum(steps2, 6)
plt.savefig('compscieng_app60wave_06.png')
\end{minted}

\includegraphics[height=6cm]{compscieng_app60wave_02.png}
\includegraphics[height=6cm]{compscieng_app60wave_06.png}

1 Hz. ve 2 Hz. seviyesindeki frekanslar ilginç, bunlar saniyede bir ve iki
adýma tekabül ediyor olmalýlar. 

Adým saymak için zaman serilerinde doruk / üç nokta bulabilen kodlar
kullanacaðýz, \verb!peakutils! altýnda bu kodlarý görüyoruz; bu kodlarla
belli eþik, minimum mesafe deðerlerini belirleyerek bir zaman serisindeki
uç noktalarý bulabiliyoruz.

\begin{minted}[fontsize=\footnotesize]{python}
import peakutils
idx = peakutils.indexes(steps2, thres=0.1, min_dist=3)
print len(idx), u'doruk noktasý var'
plt.plot(steps2)
plt.plot(idx,steps2[idx],'rd')
plt.savefig('compscieng_app60wave_03.png')
\end{minted}

\begin{verbatim}
89 doruk noktasý var
\end{verbatim}

Bu noktalarýn alt bölümü de var tabii, bu nihai sayý için üstteki sonucu
iki ile çarpabiliriz. Hesap fena deðil, bu deney için 170 adým atmýþtýk.

\includegraphics[height=6cm]{compscieng_app60wave_03.png}

\begin{minted}[fontsize=\footnotesize]{python}
idx2 = peakutils.indexes(steps2, thres=0.1, min_dist=3)
print len(idx2)
\end{minted}

\begin{verbatim}
89
\end{verbatim}

Radyo Dalgalari

\includegraphics[width=20em]{AM_waves.jpg}

\includegraphics[width=20em]{FM_waves.jpg}

\begin{minted}[fontsize=\footnotesize]{python}
import numpy as np
import matplotlib.pyplot as plt
import scipy.signal as signal
dir = "/home/burak/Documents/Dropbox/Public/data"
extract_data = np.fromfile(dir + "/fm1.dat",dtype="uint8")
interleavedData = extract_data[0::2] + 1j*extract_data[1::2]
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
plt.title("SpectoGram of 'signal' loaded from file")
plt.xlabel("Time")
plt.ylabel("Frequency")
plt.specgram(interleavedData, NFFT =1024, Fs=1140000)
plt.savefig('compscieng_app60wave_07.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_07.png}

\begin{minted}[fontsize=\footnotesize]{python}
plt.title("PSD of interleaved Data")
plt.psd(interleavedData, NFFT=1024, Fs=1140000)
plt.savefig('compscieng_app60wave_08.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_08.png}

\begin{minted}[fontsize=\footnotesize]{python}
calculate_range = max(interleavedData) - min(interleavedData);
data = (interleavedData - min(interleavedData))/ calculate_range
x1 = (data*2) - 1
plt.title("SpectoGram of signal post normalization")
plt.xlabel("Time")
plt.ylabel("Frequency")
plt.specgram(x1, NFFT =1024, Fs=1140000)
plt.savefig('compscieng_app60wave_09.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_09.png}

\begin{minted}[fontsize=\footnotesize]{python}
plt.title("PSD of normalized signal")
plt.psd(x1, NFFT=1024, Fs=1140000)
plt.savefig('compscieng_app60wave_10.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_10.png}

\begin{minted}[fontsize=\footnotesize]{python}
Fs = 1140000
fc = np.exp(-1.0j*2.0*np.pi* 250000/Fs*np.arange(len(x1)))
x2 = x1*fc
f_bw=200000
Fs=1140000
n_taps=64
lpf= signal.remez(n_taps, [0, f_bw, f_bw +(Fs/2-f_bw)/4,Fs/2], [1,0], Hz=Fs)
plt.xscale('log')
plt.title('Filter Frequency Response')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.margins(0,1)
plt.grid(which='both',axis='both')
plt.plot(w, 20*np.log10(abs(h)))
plt.savefig('compscieng_app60wave_11.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_11.png}


\begin{minted}[fontsize=\footnotesize]{python}
w,h = signal.freqz(lpf)
x3 = signal.lfilter(lpf, 1.0, x2)
plt.psd(x2, NFFT=1024, Fs=1140000, color="blue")  # original
plt.psd(x3, NFFT=1024, Fs=1140000, color="green")  # filtered
plt.title("PSD of output signal from LPF Vs Original Signal")
plt.savefig('compscieng_app60wave_12.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_12.png}

\begin{minted}[fontsize=\footnotesize]{python}
dec_rate = int(Fs/f_bw)
x4 = signal.decimate(x3, dec_rate)
Fs_x4 = Fs/dec_rate
plt.psd(x4, NFFT=1024, Fs=Fs_x4, color="blue")
plt.title("PSD of deimated signal")
plt.savefig('compscieng_app60wave_13.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_13.png}

\begin{minted}[fontsize=\footnotesize]{python}
y = x4[1:] * np.conj(x4[:-1])
x5 = np.angle(y)
plt.psd(x5, NFFT=1024, Fs=Fs_x4, color="blue")
plt.title("PSD of Post Frequency Discrimination")
plt.savefig('compscieng_app60wave_14.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_14.png}

\begin{minted}[fontsize=\footnotesize]{python}
d = Fs_x4 * 75e-6   # Calculate the # of samples to hit the -3dB point
r = np.exp(-1/d)   # Calculate the decay between each sample
b = [1-r]          # Create the filter coefficients
a = [1,-r]
x6 = signal.lfilter(b,a,x5)
plt.psd(x6, NFFT=1024, Fs=Fs_x4, color="blue")
plt.title("PSD of signal Post DeEmphasis")
plt.savefig('compscieng_app60wave_15.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app60wave_15.png}

\begin{minted}[fontsize=\footnotesize]{python}
d = Fs_x4 * 75e-6   # Calculate the # of samples to hit the -3dB point
r = np.exp(-1/d)   # Calculate the decay between each sample
b = [1-r]          # Create the filter coefficients
a = [1,-r]
dec_rate = int(Fs/f_bw)
x7=signal.decimate(x6,dec_rate)
x7*= 10000 / np.max(np.abs(x7))               # scale so it's audible
x7.astype("int16").tofile("radio.raw")
\end{minted}


\begin{verbatim}
aplay radio.raw -r 100000.0 -f S16_LE -t raw -c 1
\end{verbatim}

\begin{verbatim}
aplay radio.raw -r 45600 -f S16_LE -t raw -c 1
\end{verbatim}

[devam edecek]

Kaynaklar

[1] {\em The Basic Facts About Radio Signals}, \url{https://www.windows2universe.org/spaceweather/wave_modulation.html}

[2] \url{https://www.dropbox.com/s/lpwz2iby0nhh8p7/fm1.dat?dl=1}

[3] \url{https://www.dropbox.com/s/70adji6wyst0qbi/fm2.dat?dl=1}

[4] Scher, {\em How to capture raw IQ data from a RTL-SDR dongle and FM demodulate with MATLAB},\url{http://www.aaronscher.com/wireless_com_SDR/RTL_SDR_AM_spectrum_demod.html}

[5] {\em EE123: Digital Signal Processing}, \url{http://inst.eecs.berkeley.edu/~ee123/sp14/}

[6] Fund, {\em Capture and decode FM radio}, \url{https://witestlab.poly.edu/blog/capture-and-decode-fm-radio/}

[7] Fund, {\em Lab 1: Working with IQ data in Python}, \url{http://witestlab.poly.edu/~ffund/el9043/labs/lab1.html}

[8] Bayramlý, {\em Algýlayýcý Ölçümleri, Video, Android}, \url{http://sayilarvekuramlar.blogspot.de/2017/02/algilayici-olcumleri-video-android.html}

\end{document}


