\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Adým Ölçmek, Pedometre

Cep telefonlarýnýn çoðunda artýk ivmeölçer (acceloremeter) algýlayýcýlar
var; bu algýlayýcýlar telefonun $x,y,z$ eksenlerini baz alarak tüm
eksenlerde ne kadar ivme etkisi olduðunu ölçüyorlar. Bu etkilerden en
büyüklerinden biri tabii ki yerçekimi, telefonda hiçbir hareket olmasa bile
telefonu tutuþa göre 9.8 metre / $s^2$'lik bir ivme tek ya da tüm eksenlere
daðýlmýþ olarak ölçülecektir [4]. Yürürken, adým atarken meydana çýkan
yukarý ve aþaðý yönde kuvvet uygulamasý da ivmeölçerlerle yakalanýr. Bu
ölçümleri kullanarak acaba atýlan adým sayýsýný bulamaz mýyýz? [5]'deki
uygulamayý kullanarak alýnan ölçümlere bakalým,

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
dfacc = pd.read_csv('acc.txt',header=None,sep='\s+')
print dfacc.head()
\end{minted}

\begin{verbatim}
               0         1         2         3
0  1493818386218 -0.147100  6.972528  6.707748
1  1493818386422 -0.215746  7.001948  6.854848
2  1493818386610 -0.304006  7.041174  6.697942
3  1493818386812 -0.304006  7.050981  6.884268
4  1493818387008 -0.225553  7.011754  6.943108
\end{verbatim}

\begin{minted}[fontsize=\footnotesize]{python}
steps1 = np.sqrt(np.sum(dfacc[[1,2,3]]**2, axis=1))
steps2 = steps1 - 9.8
steps2[:200].plot()
plt.savefig('compscieng_app40walk_01.png')
\end{minted}

\includegraphics[height=6cm]{compscieng_app40walk_01.png}

Üç eksendeki ivme ölçümünün normalize ettik (karelerinin toplamýnýn
karekökü), 

$$ r = \sqrt{r_x^2 + r_y^2 + r_z^2}$$

Daha önce belirtildiðimiz gibi telefonun duruþu deðiþik þekillerde
olabilir, ve yerçekiminde olduðu gibi bu ölçümler üç eksene daðýlmýþ
olacaktýr. Bu üç ölçümü birleþtirerek esas bizi ilgilendiren hesaba daha
yaklaþmýþ olmayý umduk. 

Sonuçlar fena deðil, baþtaki sýfýra yakýn bölgede hiç hareket etmiyorduk
mesela, ve ivme hesabý burada ufak bir deðer gösteriyor. Yapýlan bir ek
iþlemden daha bahsedelim, 9.8'lik yerçekimi ivmesini karekökten çýkarttýk
çünkü yerçekimini ölçmekle de ilgilenmiyoruz (hep ayný zaten), bu deðeri
çýkartarak yine bizi ilgilendiren veriyi daha net þekilde görebileceðimizi
umduk. Altta bu çýkartma öncesi ve sonrasýnda yapýlan Fourier analizine
göre yerçekimi çýkartýlmýþ verinin ilgilendiðimiz frekanslarý daha net
gösterdiði belli oluyor.

\begin{minted}[fontsize=\footnotesize]{python}
import sys; sys.path.append('../compscieng_1_32')
import filt
f=plt.figure()
filt.plotSpectrum(steps1, 6)
plt.savefig('compscieng_app40walk_02.png')
f=plt.figure()
filt.plotSpectrum(steps2, 6)
plt.savefig('compscieng_app40walk_06.png')
\end{minted}

\includegraphics[height=6cm]{compscieng_app40walk_02.png}
\includegraphics[height=6cm]{compscieng_app40walk_06.png}

1 Hz. ve 2 Hz. seviyesindeki frekanslar ilginç, bunlar saniyede bir ve iki
adýma tekabül ediyor olmalýlar. 

Adým saymak için zaman serilerinde tepe / uç nokta bulabilen kodlar
kullanacaðýz, \verb!peakutils! altýnda bu kodlarý görüyoruz; bu kodlarla
belli eþik, minimum mesafe deðerlerini belirleyerek bir zaman serisindeki
uç noktalarý bulabiliyoruz.

\begin{minted}[fontsize=\footnotesize]{python}
import peakutils
idx = peakutils.indexes(steps2, thres=0.1, min_dist=3)
print len(idx), u'tepe noktasý var'
plt.plot(steps2)
plt.plot(idx,steps2[idx],'rd')
plt.savefig('compscieng_app40walk_03.png')
\end{minted}

\begin{verbatim}
89 tepe noktasý var
\end{verbatim}

Bu noktalarýn alt bölümü de var tabii, bu nihai sayý için üstteki sonucu
iki ile çarpabiliriz. Hesap fena deðil, bu deney için 170 adým atmýþtýk.

\includegraphics[height=6cm]{compscieng_app40walk_03.png}

Tepe bulmaktaki farklý parametre etkilerini de gösterelim. Önce gürültülü,
iki büyük tepeden oluþan bir yapay veri üretelim,

\begin{minted}[fontsize=\footnotesize]{python}
import peakutils
np.random.seed(0)
centers = (30.5, 72.3)
x = np.linspace(0, 120, 121)
y = peakutils.gaussian(x, 5, centers[0], 3) + \
    peakutils.gaussian(x, 7, centers[1], 10) + \
    np.random.rand(x.size)
\end{minted}

Þimdi farklý parametrelerle tepe noktalarýný bulalým,

\begin{minted}[fontsize=\footnotesize]{python}
plt.figure()
plt.plot(x, y)
indexes = peakutils.indexes(y, thres=0.5, min_dist=30)
plt.plot(x[indexes], y[indexes], 'rd')
plt.savefig('compscieng_app40walk_04.png')
plt.figure()
plt.plot(x, y)
indexes = peakutils.indexes(y, thres=0.5, min_dist=3)
plt.plot(x[indexes], y[indexes], 'rd')
plt.savefig('compscieng_app40walk_05.png')
plt.figure()
plt.plot(x, y)
indexes = peakutils.indexes(y, thres=0.1, min_dist=5)
plt.plot(x[indexes], y[indexes], 'rd')
plt.savefig('compscieng_app40walk_07.png')
\end{minted}

\includegraphics[height=4cm]{compscieng_app40walk_04.png}
\includegraphics[height=4cm]{compscieng_app40walk_05.png}
\includegraphics[height=4cm]{compscieng_app40walk_07.png}

Parametre \verb!thres! dikey bir eþik deðeri tanýmlýyor, en yüksek nokta
1.0 olacak þekilde. Mesela yarým seviyede minimal bir yükseklik eþik deðeri
0.5 ile tanýmlanabilir, o zaman sadece bu deðer üstündeki noktalar tepe
olarak saptanacaktýr. Yatay yönde ama bu sefer reel deðer bazlý bir eþik
deðeri \verb!min_dist! ile verilir, bu durumda tepe noktalarý arasýnda en
az bu kadar mesafe olmasý gerekir.

Yürüyüþ Yönünü Bulmak

Cep telefonuyla hangi yöne yürüdüðümüzü nasýl buluruz? Bilim kurgu filmleri
izleyici olan bizleri biraz sükseli uygulamalara alýþtýrdý -zamanda
seyahat, istediði yere inen uzay gemileri, ýþýktan hýzlý seyahat gibi-
fakat cep telefonu ile yürüyüþ yönünü hesaplamak 2014 civarýna kadar hala
tam, genel bir þekilde çözülmüþ deðildi. GPS ise yaramýyor mu? GPS kesin
çözüm olabilirdi, dünya üzerinde global kordinatlarý direk alýyoruz, fakat
GPS þehir ortamýnda binalardan sinyal yansýmasý (multipath) problemi
sebebiyle herhangi bir yönde birkaç yüz metre hatalý olabiliyor, ve kapalý
alanlarda GPS sinyali alamýyoruz.

Yürüyüþ yönü çözümü için daha önce adým sayýsýnda olduðu gibi ivmeölçer
kullanýmý akla gelecektir, ivmeölçer önemli, fakat bu algýlayýcýlarýn
kaydettikleri yürüyüþ sýrasýnda pek çok diðer hareket ile karýþmýþ
halde. Sallanma, aþaðý yukarý gidiþ geliþ gibi. Ayrýca ivmeölçerin
kaydettiði telefon bazlý bir eksen sistemine göre, bu sistem

\includegraphics[width=10em]{compscieng_app40walk_08.png}

Eðer telefonu ekraný bana tam yere dik þekilde tutup yürürsem ivmeölçer y
kordinatýnda daha yüksek deðerler kaydediyor mesela. Bu bilgiyi alýp
telefonun bir diðer algýlayýcýsý elektronik pusula / manyetometre
(magnetometer) üzerinden bir global yön bilgisine belki çevirebilirim,
fakat pusula da tam güvenli deðil, bu birleþtirmeyi dikkatli yapmak lazým.

Bu birleþtirme için çoðunlukla Android ortamýnda rotasyon matrisi [3]
kavramý tavsiye edenler var; bu kavrama göre ivmeölçer ve pusula
birleþtirilip kamera kordinat sistemini dünya kordinate sistemine tercüme
edecek bir matris hesaplanýyor. Fakat bu hesap hareketli ortamda tam
güvenilir deðil, ayrýca hesaplanan çok boyutlu, çok çetrefil bir þey. Bu
tür girift ara ürünler nihai çözümdeki hata ihtimalini daha arttýrýr, bize
gereken tek bir yön sadece, {\em tüm} üç boyutlu eksenin bir diðer üç
boyutlu eksene direk eþlemesi biraz fazla. Bir diðer problem bu hesabýn
nasýl kullanýlacaðýnda. Mesela ivme hesaplarýný rotasyon matrisý ile dünya
kordinat sýstemine çevirdik, þimdi kuzey-güney doðu-batý baðlamýnda
ivlenmeyi biliyoruz. Bu ivmelenmeyi bir kere sayýsal entegrasyon ile hýza
çevirip oradan yön elde edebilir miyiz?  Ne yazýk ki bu yöntemin de hassas
olduðunu biliyoruz. Eðer olmayan yerde birkaç saniye fazla ivme ölçümü bile
hýzda, yönde aþýrý farklýlýklar yaratabiliyor.

Çözüm için yürüyüþün ivmeölçere nasýl yansýdýðýný yakýndan incelemek
gerekiyor, ki [1, 2]'deki araþtýrma aynen bunu yapmýþ. Dikkat: bugünlerde
moda olan veri bilimi denen bir dal var, burada mühendislerin ilk refleksi
elde olan bir sürü veriyi bir yapay öðrenim algoritmasina vermek oluyor, ve
yapay öðrenim algoritmasi bir þeyler ``öðreniyor'', ve birdenbire bize yeni
veriler / ortamlar için doðru sonuçlar vermeye baþlýyor. Bu yaklaþým her
zaman iþlemiyor, problem alanýný yakýndan gözlemek her zaman faydalýdýr,
onu elden geldiði kadar matematiksel olarak modellemeye uðraþmamýz
lazým. Aradýðýmýz çok hassas olmayan, genel, geniþ tekrar eden bir kalýbý,
bir sinyali yakalamaya uðraþmak olmalý. 

\begin{minted}[fontsize=\footnotesize]{python}
import pandas as pd
import pandas as pd, health
import scipy.linalg as lin

dir = './data/pots1/'
dfacc = pd.read_csv(dir + 'lacc.txt',header=None,sep='\s+')
fr=100; to=250
dfacc = np.array(dfacc)[fr:to]
t = dfacc[:,0] / 1e9
ax = dfacc[:,1]
ay = dfacc[:,2]
az = dfacc[:,3]
data = np.abs(ax) + np.abs(ay) + np.abs(az)

sample_rate = 25.0
cutoff = 5.0
threshold = 0.1
order=4
stride_fraction = 1.0/8.0
\end{minted}


\begin{minted}[fontsize=\footnotesize]{python}
# Sum of absolute values across accelerometer axes:
data = np.abs(ax) + np.abs(ay) + np.abs(az)

# Find maximum peaks of smoothed data:
plot_test2 = False

# Demean data
data -= np.mean(data)

# Low-pass filter the AP accelerometer data by the 4th order zero lag
# Butterworth filter whose cut frequency is set to 5 Hz:
filtered = health.butter_lowpass_filter(data, sample_rate, cutoff, order)

# Find transitional positions where AP accelerometer changes from
# positive to negative.
transitions = health.crossings_nonzero_pos2neg(filtered)

f=plt.figure()
plt.plot(filtered)
plt.plot(transitions,filtered[transitions],'rd')
plt.savefig('compscieng_app40walk_09.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app40walk_09.png}


\begin{minted}[fontsize=\footnotesize]{python}
strike_indices_smooth = []
filter_threshold = np.abs(threshold * np.max(filtered))
for i in range(1, np.size(transitions)):
    segment = range(transitions[i-1], transitions[i])
    imax = np.argmax(filtered[segment])
    if filtered[segment[imax]] > filter_threshold:
        strike_indices_smooth.append(segment[imax])

f=plt.figure()
plt.plot(filtered)
plt.plot(strike_indices_smooth,filtered[strike_indices_smooth],'rd')
plt.plot(transitions,filtered[transitions],'gx')
plt.savefig('compscieng_app40walk_10.png')

# Compute number of samples between peaks using the real part of the FFT:
interpeak = health.compute_interpeak(data, sample_rate)
decel = np.int(interpeak / 2)
print 'decel', decel

# Find maximum peaks close to maximum peaks of smoothed data:
strike_indices = []
for ismooth in strike_indices_smooth:
    istrike = np.argmax(data[ismooth - decel:ismooth + decel])
    istrike = istrike + ismooth - decel
    strike_indices.append(istrike)

strikes = np.asarray(strike_indices)
strikes -= strikes[0]
strikes = strikes / sample_rate

print np.unique(strike_indices)

f=plt.figure()
plt.plot(data)
plt.plot(strike_indices,data[strike_indices],'rd')
plt.savefig('compscieng_app40walk_11.png')
\end{minted}

\includegraphics[width=20em]{compscieng_app40walk_10.png}

\includegraphics[width=20em]{compscieng_app40walk_11.png}


\begin{verbatim}
decel 37
[ 64  93 107 121]
\end{verbatim}

Kaynaklar

[1] Roy, {\em WalkCompass: Finding Walking Direction Leveraging Smartphone's Inertial Sensors}, \url{http://scholarcommons.sc.edu/etd/2352/}

[2] Roy, {\em I am a Smartphone and I can Tell my User's Walking Direction}, \url{http://synrg.csl.illinois.edu/papers/walkcompass.pdf} 

[3] Google, {\em Position Sensors} \url{https://developer.android.com/guide/topics/sensors/sensors_position.html}

[4] Daskalov, {\em A Pedometer in the Real World}, \url{http://www.aosabook.org/en/500L/a-pedometer-in-the-real-world.htm}

[5] Bayramlý, {\em Algýlayýcý Ölçümleri, Video, Android}, \url{http://sayilarvekuramlar.blogspot.de/2017/02/algilayici-olcumleri-video-android.html}

\end{document}


















