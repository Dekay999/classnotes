\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Dairesel Baz Fonksiyonlari (Radial Basis Functions -RBF-), Yukseklik Verisi, Daglar

Ara deðerlemek (interpolation), yani elde olan veriyi kullanýp olmayan hakkýnda
tahmin yapmaya uðraþmak için çok boyutlu ortamda RBF iyi iþleyen bir
yaklaþýmdýr. Belki de zihinde en rahat canlandýrýlabilecek örnek yeryüzünde
ovalara, daðlara ovalara tekabül eden yükseklik (elevation) verilerini alarak
onlara sürekli tepe fonksiyonlarý ``uydurmak'' böylece daðlarýn nerede olduðunu
saptamak. çözünürlükte yükseklik verisi ise yaramayabilir, eðer bir nokta daðýn
bir eteðinde diðeri öte yanindaki eteðinden alýnmýþsa bu dað yok anlamýna
gelecektir. 

Peki yükseklik verisinýn geldiði yerden daha yüksek çözünürlüklü veri almýyoruz?
Bu hem eriþim hem de tutacaðý yer baðlamýnda pahalý olabilir. 1 derecelik enlem
/ boylam içinde, mesela 36-37 ve 32-33 arasý diyelim, 100 metrelik çözünürlük
demek 0.001 derece deðiþimine tekabül eder, ve bu durumda 1 milyon veri noktasý
alýnmasý gerekecektir. Halbuki yükseklik verisinden yüzde 3 miktarýnda bile bir
rasgele örneklem alýrsak, bu noktalara RBF ile tepe fonksiyonlarý uydurarak
matematiksel, sürekli olan bir genel fonksiyon elde ederiz, ve uydurma iyi
iþlerse artýk istediðimiz çözünürlükte yükseklik verisi elde edebiliriz. 

 

$$
\left[\begin{array}{rrr}
\exp(-\gamma \|x_1-x_1\|^2) & \cdots & \exp(-\gamma \|x_1-x_N\|^2)\\
\exp(-\gamma \|x_2-x_1\|^2) & \cdots & \exp(-\gamma \|x_2-x_N\|^2)\\
\vdots & \ddots & \vdots \\
\exp(-\gamma \|x_N-x_1\|^2) & \cdots & \exp(-\gamma  \|x_N-x_N\|^2)
\end{array}\right]
\left[\begin{array}{r}
 w_1  \\
 w_2  \\
 \vdots \\
 w_N
\end{array}\right] =
\left[\begin{array}{rrr}
 y_1  \\
 y_2  \\
 \vdots \\
 y_N
\end{array}\right]
$$




\begin{minted}[fontsize=\footnotesize]{python}
from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt from
matplotlib import cm import numpy as np import matplotlib.pyplot as plt import
numpy.linalg as lin from scipy.spatial.distance import cdist
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
np.random.seed(0)

def func(x, y):
    s1 = 0.2; x1 = 36.5; y1 = 32.5
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    s2 = 0.4; x2 = 36.1; y2 = 32.8
    g1 = np.exp( -4 *np.log(2) * ((x-x1)**2+(y-y1)**2) / s1**2)
    g2 = np.exp( -2 *np.log(2) * ((x-x2)**2+(y-y2)**2) / s2**2)    
    return g1 + g2 

D = 50
S = 100
gamma = 2.0

x = np.linspace(36,37,D)
y = np.linspace(32,33,D)

xx,yy = np.meshgrid(x,y)
zz = func(xx,yy)

fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, zz, cmap=cm.coolwarm,linewidth=0, antialiased=False)
fig.colorbar(surf, shrink=0.5, aspect=5)
plt.savefig('linear_app88rbf_01.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_01.png}

\begin{minted}[fontsize=\footnotesize]{python}
xxx = xx.reshape(D*D)
yyy = yy.reshape(D*D)
zzz = zz.reshape(D*D)

idx = np.random.choice(range(D*D),S)

xr = xxx[idx].reshape(S,1)
yr = yyy[idx].reshape(S,1)
zr = zzz[idx].reshape(S,1)
X = np.hstack((xr,yr))

Phi = np.exp(-gamma*cdist(X,X,metric='euclid'))

w = np.dot(lin.pinv(Phi),zr)
a = np.vstack((xxx,yyy))
d = cdist(X,a.T)
d = np.exp(-gamma * d)
dd = np.dot(w.T,d)
znew = dd.reshape(D,D)
\end{minted}

\begin{minted}[fontsize=\footnotesize]{python}
fig = plt.figure()
ax = fig.gca(projection='3d')
surf = ax.plot_surface(xx, yy, znew, cmap=cm.coolwarm,linewidth=0, antialiased=False)
fig.colorbar(surf, shrink=0.5, aspect=5)
plt.savefig('linear_app88rbf_02.png')
\end{minted}

\includegraphics[width=20em]{linear_app88rbf_02.png}











Kaynaklar

[1] Neto, {\em Radial Basis Functions}, \url{http://www.di.fc.ul.pt/~jpn/r/rbf/rbf.html}

\end{document}






