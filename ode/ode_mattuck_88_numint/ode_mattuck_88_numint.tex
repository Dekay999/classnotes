\documentclass[12pt,fleqn]{article}\usepackage{../../common}
\begin{document}
Sayýsal Fonksiyonlarý Sayýsal Entegre Etmek

Bir ODE ya da ODE sisteminin sonucunu almak için Euler yöntemini gördük, bu
yöntem aslýnda bir entegrasyondur, daha doðrusu analitik fonksiyonun
sayýsal entegrasyonudur. Fakat ya ortada analitik fonksiyon olmasaydý,
elimizde sadece belli noktalarda toplanmýþ ``veri noktalarý'' olsaydý? O
zaman sayýsal fonksiyonlarýn sayýsal entegrasyonunu görmemiz lazým.

Newton-Cotes Entegrasyonu

NC yöntemine göre sadece sayýsal deðerleri olan $f(x)$'i entegre etmek için
ona iyi uyan bir yaklaþýk ama analitik baþka bir fonksiyon bulunur ve bu
metot analitik ya da sayýsal olarak entegre edilir. Mesela $f(x)$ yerine
$f_n(x)$ kullanarak,

$$ \int_a^b f(x) \ud x \approx \int _{a}^{b} f_n(x) \ud x $$

$$ f_n(x) = a_0 + a_1x + ... + a_nx^n $$

Yani polinom uydurmus olduk. Veriye polinom uydurmak için bilinen yöntemler
var, bunlardan biri kullanýlýr, polinom $f_n$ elde edilir, ve o entegre
edilir. Polinomlarýn entegrasyonu kolay, $a_0 + a_1x + ..$'in entegrali
mesela $a_0x + a_1x^2/2 + ...$.

Ýkizkenar Yamuk (Trapezoid) Kuralý

Entegral hesabý bir alan hesabý olduðuna göre $a,b$ noktalarý arasýndaki
alaný bir ikizkenar yamuk ile yaklaþýk olarak temsil edersek, bir ikizkenar
yamuðun alaný nasýl hesaplanýr biliyoruz [1], bu hesabý uygularýz,

\includegraphics[width=20em]{ode_mattuck_88_numint_02.png}

Üstteki yamuðun alaný $A = \frac{a+b}{2} h$. Bu formülü alttaki
parametrelere uygularsak,

\includegraphics[width=20em]{ode_mattuck_88_numint_01.png}

Þu formülü

$$ Alan = (b-a) \frac{f(b)-f(a)}{2}$$

elde ederiz. O zaman entegrasyon yapmak istediðimiz herhangi iki nokta
arasýnda $n$ parça tanýmlarýz (parçalarýn eþit aralýklý olmasý mecbur
deðildir), 

$$ a = x_0 \le x_1 \le x_2 \le ... \le x_n = b$$

Entegral

$$ 
\int _{a}^{b} f(x) \ud x \approx \sum _{i=0}^{n-1} 
\frac{1}{2} \big( x_{i+1}-x_i \big) \big( f(x_{i+1})-f(x_i) \big)
$$

Örnek

$$ \int _{0}^{\pi} \sin(x) \ud x $$

Baþlangýçta sayýsal fonksiyon dedik ama üstteki fonksiyon analitik, neyse
örnek amaçlý onun sayýsal halini kullanalým,

\begin{minted}[fontsize=\footnotesize]{python}
X = np.linspace(0,np.pi,100)
Y = np.sin(X)
Z = np.trapz(Y,X)
print Z
\end{minted}

\begin{verbatim}
1.99983216389
\end{verbatim}

Analitik olarak kontrol etmek gerekirse, $\int \sin = -\cos(x) + C$,
analitik entegral $-\cos(\pi) + \cos(0) $

\begin{minted}[fontsize=\footnotesize]{python}
print -np.cos(np.pi) + np.cos(0)
\end{minted}

\begin{verbatim}
2.0
\end{verbatim}

Örnek

Þimdi pür sayýsal fonksiyon görelim. Alttaki deðerler bir cismin belli
noktalardaki hýzýný temsil ediyor. Bu cismin zaman 0 ve 3 arasýndaki
katettiði mesafeyi bulun. 

$$ 
\begin{tabular}{c|c}
Zaman (saniye) & Hýz (metre) \\ \hline
0.0 & 0.0 \\ 1.0 & 10.0 \\ 2.0 & 12 \\ 3.0 & 14
\end{tabular}
$$

Mesafenin hýzýn entegrali olduðunu biliyoruz, bkz. {\em Temel Fizik, Ývme,
  Hýz, Yerçekimi} notlarý,

$$ Mesafe = \int _{0}^{3} V(t) \ud t$$

Ýkiz yamuk yöntemi ile

\begin{minted}[fontsize=\footnotesize]{python}
x = [0,1,2,3]
y = [0, 10, 12, 14]
print np.trapz(y,x), 'metre'
\end{minted}

\begin{verbatim}
29.0
\end{verbatim}

Eðer elle hesaplasaydýk,

$$ h = x_{i+1} - x_i = 1$$

$$ T = h 
\bigg[ 
\sum _{i=1}^{n-1} f(x_i) + \frac{1}{2} \big( f(x_0) + f(x_n) \big)
\bigg]
$$

$$ = 1 \bigg[ (10+12) + \frac{1}{2}(0+14) \bigg] = 29 $$

Ývmeden Mesafe Hesabý

Eðer elimizde ivme var ise, mesafe nasýl hesaplarýz? Bu durumda iki kere
entegral almak lazým, ilk entegralle ivmeden hýz, ikincisi hýzdan
mesafe. Fakat kullanýlan paket program baðlamýnda bir sorun
\verb!numpy.trapz!'nin entegral bir vektörü alýp geriye tek bir sayý deðeri
döndürmesi... Bu entegral sonucu, normalde bu beklenen sonuç, fakat hýz
bize bir zaman serisi olarak gelmeli ki onun da entegralini alarak mesafeyi
elde edelim.

Acaba $t_0,t_N$ arasýnda $t_0,t_1$, sonra $t_0,t_2$, .. olacak þekilde
\verb!trapz! hesabý yapsak ve bu deðerleri hatýrlayarak bir hýz vektörü
oluþtursak? 

Örnek veri: Elimizde cep telefonu kullanarak alýnmýþ ivme ölçümleri var. Bu
ölçümleri [2] ile topladýk, ve [3]'te görüldüðü gibi bir sayýsal
entegrasyon yapacaðýz. 

\includegraphics[width=25em]{ode_mattuck_88_numint_03.png}

Hýz için gereken entegrasyon ivme $a$ üzerinde alýnýr,

$$ 
v(t_2)-v(t_1) = \int _{t_1}^{t_2} a(t) \ud t \approx 
\sum _{t_1}^{t_2} \frac{1}{2} (a_i + a_{i+1}) \Delta t
$$

Sonra hýzý da entegre ederek mesafeyi elde ederiz. Altta harita üzerinde
alýnan direk mesafeyi grafiklemek için bazý rutinler var. Baþlangýç enlem /
boylamdan açý, katedilen yol verilince yeni enlem boylam
hesaplanýyor, verili harita üzerinde grafikleme yapýlabiliyor.

\begin{minted}[fontsize=\footnotesize]{python}
from PIL import Image, ImageDraw, ImageFont
import pandas as pd, io, math, re
from io import BytesIO
from PIL import Image

R = 6378.1 #Radius of the Earth

# pixel <-> lat/lon conversion, found by trial and error
scales = {18: (1.8e5, -2.5e5), 17: (1.0e5, -1.52e5), 15: (23000., -40000.) }

def travel(lat, lon, bearing, distance):
    # yon (bearing) bu kodun orijinalinde y-ekseninden saat yonune 
    # dogru olan aci olarak alinmis. Biz aciyi  (ustteki argumanda) 
    # x-eksenden saat yonu tersi olacak sekilde kabul ediyoruz, sonra 
    # alttaki koda gore cevrim yapiyoruz, ki tanidik matematik formulleri 
    # kullanilabilsin.
    brng = (450-bearing) % 360
    # mesafe kilometre
    lat1 = math.radians(lat) #Current lat point converted to radians
    lon1 = math.radians(lon) #Current long point converted to radians
    lat2 = math.asin( math.sin(lat1)*math.cos(distance/R) +
                      math.cos(lat1)*math.sin(distance/R)*math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng)*math.sin(distance/R)*math.cos(lat1),
                             math.cos(distance/R)-math.sin(lat1)*math.sin(lat2))
    return (math.degrees(lat2), math.degrees(lon2))

def plot_line_gm(mapfile, pts, outfile):
    SCALEX,SCALEY = scales[17]
    tmp = re.findall("(-*\d+)_(\d+)_(-*\d+)_(\d+)",mapfile,re.DOTALL)[0]
    nim = Image.open(mapfile)
    w,h = np.array(nim).shape
    c = (w/2,h/2)
    center_lat = float(tmp[0] + "." + tmp[1])
    center_lon = float(tmp[2] + "." + tmp[3])
    line = []
    for i,pt in enumerate(pts):
    	dx,dy=((pt[1]-center_lon)*SCALEX,(pt[0]-center_lat)*SCALEY)
    	line.append((c[0]+dx,c[1]+dy))
    d = ImageDraw.Draw(nim)
    d.line(line)
    nim.save(outfile)
\end{minted}

Bilinen bir baþlangýç noktasýndan 20 derece doðuya 30 metre gitmek, 

\begin{minted}[fontsize=\footnotesize]{python}
mf = 'berlin_52_5009766667_13_312235.png'
ref = [52.502035, 13.312638]
plot_line_gm(mf, [ref, travel(ref[0], ref[1], np.deg2rad(20), 0.030)], 'ku1.png')
\end{minted}

\includegraphics[width=25em]{ku1.png}

Toplanan yürüyüþ verisine gelelim. Bu veride üstteki baþlangýç noktasýndan
önce doðuya yaklaþýk 30 metre, sonra güneye doðru 100 metre kadar yürüdük,
ortadaki ana yol boyunca, onun solunda. [2]'de bahsedilen araç telefonun
rotasyon matrisini (rotation matrix) ve ham ivme verilerini kaydetti. Ývme
verileri telefonun kordinat sýstemine göre, ve her eksen için ayrý ayrý,
rotasyonda telefonun dünya kordinatýna göre nasýl durduðu
gösterilir. Ývmeyi dünya kordinatlarýna çevirmek için (kuzeye ne kadar,
doðuya ne kadar ivmem var?) üç boyutlu ivme vektörü rotasyon matrisý ile
çarpýlýr.

Altta bu iþlem yapýlýyor, ve her eksen için (daha doðrusu $x,y$ için, $z$
ile ilgilenmiyoruz) sayýsal entegrasyon yapýlýyor. 

\begin{minted}[fontsize=\footnotesize]{python}
idx = 80
dfacc = np.array(pd.read_csv('acc.txt',header=None,sep='\s+'))
dfrot = pd.read_csv('rotations.txt',header=None,sep='\s+')
dt = np.array(dfrot.diff().fillna(0))[:,0] # zaman
dfrot = np.array(dfrot)

v = np.zeros((len(dt), 2))
s = np.zeros((len(dt), 2))
a = np.zeros((len(dt), 2))

for i in range(idx,len(dfacc)):
    tmp = np.dot(dfrot[i,1:].reshape((3,3)), dfacc[i, 1:])
    a[i,0] = tmp[0]; a[i,1] = tmp[1]
   
for i in range(idx,len(a)):
    v[i]=v[i-1]+(0.5*(a[i-1]+a[i])*dt[i]);
    s[i]=s[i-1]+(0.5*(v[i-1]+v[i])*dt[i]);

# uzaklik hesabinda iyi sonuc veren elle secilmis bir sabit
C = 150. 
coords = []
for i in range(idx,len(a)):
    xx = s[i]
    bearing = np.arctan2(xx[1], xx[0])
    dist = np.sqrt(xx[0]**2+xx[1]**2) / C
    lat,lon = travel(ref[0], ref[1], bearing, dist)
    coords.append([lat,lon])
coords = np.array(coords)
plot_line_gm(mf, coords, 'ku2.png')
\end{minted}

\includegraphics[width=20em]{ku2.png}

Gidiþ yaklaþýk olarak hesaplandý. Ývme algýlýyýcýlarý tabii ki tüm diðer
algýlayýcýlar gibi oldukca gürültü içeriyorlar. Bu ölçümü GPS (ki þehir
içinde o da çok gürültülü sonuçlar içerir) birleþtirerek, iþin içine
bilinen harita dahil ederek, ve diðer ek taklalarla sonucu git gide
düzeltmek mümkündür.

Ayrýca üstteki iþlemleri otomatik yapan \verb!scipy.integrate.cumtrapz!
çaðrýsý var, yani kümülatif hesabý kendiliðinden yapýyor. Bu çaðrýya N
büyüklüðündeki vektör verince N büyüklüðünde vektör elde ediyoruz. Sonra
devam ederek \verb!trapz! çaðrýsý yapýyoruz.

Kaynaklar

[1] Sertel, {\em Numerical Integration}, \url{http://web.itu.edu.tr/~sertele/dersler/matlab/ders09.pdf}

[2] Bayramlý, {\em Algýlayýcý Ölçümleri, Video, Android}, \url{http://sayilarvekuramlar.blogspot.co.uk/2017/02/algilayici-olcumleri-video-android.html}

[3] Latcha, {\em EGR 280 - Introduction to Mechanics, Lab}, \url{www.secs.oakland.edu/~latcha/EGR280/AccelerationLab.doc}

\end{document}
